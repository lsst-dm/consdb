#!/usr/bin/env python3
"""
Validate Alembic migrations against SDM schema YAMLs.

This script:
1) Runs alembic-autogenerate.py and confirms the generated migration has
   exactly two "pass" lines between autogen markers, indicating that
   the migration agrees with the sdm_schemas YAML file.
2) Uses a temporary PostgreSQL instance to upgrade to head, downgrade -1,
   and compares the resulting schema to sdm_schemas-old. This ensures that
   the downgrade method in the migration correctly returns the database
   to its old state.
3) Runs two upgrade/downgrade cycles against CONSDB_URL. This step is
   optional but recommended.
   NOTE: set CONSDB_URL to a local instance of postgres, not BTS, TTS, USDF,
   or Summit.

You will need before and after copies of the sdm_schemas repo. For the
"after" repo, the location pointed to by SDM_SCHEMAS_DIR is the default,
or ${CONSDB_DIR}/sdm_schemas if that environment variable is not set.
For the "before" repo, ${CONSDB_DIR}/sdm_schemas-old is the default.
Both of these can be changed by arguments to this script.
"""

import argparse
import os
import re
import subprocess
import sys
from enum import IntEnum
from pathlib import Path

import sqlalchemy as sa
import yaml
from felis.datamodel import Schema
from felis.metadata import MetaDataBuilder
from felis.tests.postgresql import setup_postgres_test_db
from sqlalchemy.sql import text

from alembic.autogenerate import compare_metadata
from alembic.migration import MigrationContext

REPO_ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(REPO_ROOT / "python"))
from lsst.consdb.cdb_pgsphere import add_shadow_column  # noqa: E402

AUTOGEN_MARKER_START = "# ### commands auto generated by Alembic - please adjust! ###"
AUTOGEN_MARKER_END = "# ### end Alembic commands ###"


class ExitCode(IntEnum):
    OK = 0
    DIFFS_FOUND = 1


def run(cmd: list[str], *, env: dict[str, str] | None = None) -> None:
    """Run a subprocess command and echo it to stdout."""
    print("+", " ".join(cmd))
    subprocess.run(cmd, check=True, env=env)


def _read_autogen_pass_count(path: Path) -> int:
    """Count 'pass' lines in the autogen section of a migration file."""
    in_block = False
    count = 0
    for line in path.read_text().splitlines():
        stripped = line.strip()
        if stripped == AUTOGEN_MARKER_START:
            in_block = True
            continue
        if stripped == AUTOGEN_MARKER_END:
            in_block = False
            continue
        if in_block and re.match(r"^\s*pass$", line):
            count += 1
    return count


def _find_new_delete_me(versions_dir: Path, before: set[Path]) -> Path:
    """Locate the newly created delete_me migration file."""
    after = {path for path in versions_dir.glob("*_delete_me.py")}
    new_files = after - before
    if len(new_files) != 1:
        new_names = ", ".join(sorted(p.name for p in new_files))
        raise RuntimeError(f"Expected exactly one new delete_me file, found {len(new_files)}: {new_names}")
    return new_files.pop()


def _load_metadata(yaml_path: Path) -> sa.MetaData:
    """Build SQLAlchemy metadata from a Felis YAML schema."""
    schema = Schema.from_uri(yaml_path, context={"id_generation": True})
    metadata = MetaDataBuilder(schema).build()
    add_shadow_column(metadata)
    return metadata


def _include_name(schema_name: str):
    """Create a name filter to scope Alembic comparisons to one schema."""

    def include_name(name: str, type_: str, parent_names: dict[str, str]) -> bool:
        if type_ == "schema":
            return name == schema_name
        return True

    return include_name


def _include_object(object_, name: str, type_: str, reflected: bool, compare_to) -> bool:
    """Exclude legacy visit1 views from Alembic schema comparisons."""
    if type_ == "table" and name in {"ccdvisit1", "visit1"}:
        return False
    return True


def _compare_schema(connection: sa.engine.Connection, metadata: sa.MetaData, schema_name: str) -> list:
    """Compare a live schema against expected metadata."""
    context = MigrationContext.configure(
        connection,
        opts={
            "compare_type": True,
            "compare_server_default": True,
            "include_schemas": True,
            "include_name": _include_name(schema_name),
            "include_object": _include_object,
            "target_metadata": metadata,
        },
    )
    return compare_metadata(context, metadata)


def main() -> int:
    """CLI entry point for migration validation."""
    parser = argparse.ArgumentParser(description="Validate ConsDB migrations.")
    parser.add_argument("--instrument", default="latiss", help="Instrument name (default: latiss).")
    parser.add_argument(
        "--sdm-schemas-dir",
        default=os.environ.get("SDM_SCHEMAS_DIR", str(REPO_ROOT / "sdm_schemas")),
        help="Path to sdm_schemas (current).",
    )
    parser.add_argument(
        "--sdm-schemas-old-dir",
        default=str(REPO_ROOT / "sdm_schemas-old"),
        help="Path to sdm_schemas-old (unmodified).",
    )
    parser.add_argument(
        "--keep-delete-me",
        action="store_true",
        help="Keep the autogenerated delete_me migration file.",
    )
    args = parser.parse_args()

    instrument = args.instrument
    sdm_schemas_dir = Path(args.sdm_schemas_dir).resolve()
    sdm_schemas_old_dir = Path(args.sdm_schemas_old_dir).resolve()
    if not sdm_schemas_dir.is_dir():
        raise RuntimeError(f"sdm_schemas dir not found: {sdm_schemas_dir}")
    if not sdm_schemas_old_dir.is_dir():
        raise RuntimeError(f"sdm_schemas-old dir not found: {sdm_schemas_old_dir}")

    versions_dir = REPO_ROOT / "alembic" / instrument / "versions"
    before_delete_me = {path for path in versions_dir.glob("*_delete_me.py")}

    env = os.environ.copy()
    env["SDM_SCHEMAS_DIR"] = str(sdm_schemas_dir)

    run(
        [
            sys.executable,
            str(REPO_ROOT / "alembic-autogenerate.py"),
            "--instrument",
            instrument,
            "delete me",
        ],
        env=env,
    )
    delete_me_path = _find_new_delete_me(versions_dir, before_delete_me)
    pass_count = _read_autogen_pass_count(delete_me_path)
    if pass_count != 2:
        raise RuntimeError(f"Expected exactly 2 pass lines in {delete_me_path.name}, found {pass_count}")
    if not args.keep_delete_me:
        delete_me_path.unlink()

    schema_name = f"cdb_{instrument}"
    old_yaml_path = sdm_schemas_old_dir / "yml" / f"{schema_name}.yaml"
    if not old_yaml_path.is_file():
        raise RuntimeError(f"Old YAML not found: {old_yaml_path}")

    metadata = _load_metadata(old_yaml_path)

    with setup_postgres_test_db() as instance:
        with instance.engine.begin() as connection:
            connection.execute(text("CREATE EXTENSION IF NOT EXISTS pg_sphere;"))
            connection.execute(text("CREATE SCHEMA cdb;"))
            connection.execute(text(f"CREATE SCHEMA {schema_name};"))
            connection.execute(text("CREATE USER usdf;"))
            connection.execute(text("CREATE USER oods;"))

        temp_env = env.copy()
        temp_env["CONSDB_URL"] = instance.url
        run(["alembic", "-c", "alembic.ini", "-n", instrument, "upgrade", "head"], env=temp_env)
        run(["alembic", "-c", "alembic.ini", "-n", instrument, "downgrade", "-1"], env=temp_env)

        with instance.engine.connect() as connection:
            diffs = _compare_schema(connection, metadata, schema_name)
        if diffs:
            print("Schema differences found after downgrade:")
            for diff in diffs:
                print(diff)
            return ExitCode.DIFFS_FOUND

    consdb_url = os.environ.get("CONSDB_URL")
    if not consdb_url:
        print("WARNING: CONSDB_URL not set. Skipping test on live postgresql instance.")
    else:
        live_env = env.copy()
        live_env["CONSDB_URL"] = consdb_url
        for cycle in range(1, 3):
            print(f"Cycle {cycle}: upgrade -> downgrade")
            run(["alembic", "-c", "alembic.ini", "-n", instrument, "upgrade", "head"], env=live_env)
            run(["alembic", "-c", "alembic.ini", "-n", instrument, "downgrade", "-1"], env=live_env)

    print("All checks passed.")
    return ExitCode.OK


if __name__ == "__main__":
    raise SystemExit(main())
